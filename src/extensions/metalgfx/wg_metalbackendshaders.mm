/*=========================================================================

                         >>> WonderGUI <<<

  This file is part of Tord Jansson's WonderGUI Graphics Toolkit
  and copyright (c) Tord Jansson, Sweden [tord.jansson@gmail.com].

                            -----------

  The WonderGUI Graphics Toolkit is free software; you can redistribute
  this file and/or modify it under the terms of the GNU General Public
  License as published by the Free Software Foundation; either
  version 2 of the License, or (at your option) any later version.

                            -----------

  The WonderGUI Graphics Toolkit is also available for use in commercial
  closed-source projects under a separate license. Interested parties
  should contact Tord Jansson [tord.jansson@gmail.com] for details.

=========================================================================*/

#include <wg_metalbackend.h>

namespace wg {


const char MetalBackend::shaders[] =

"\n"
"#include <metal_stdlib>\n"
"using namespace metal; \n"
"\n"
"\n"
"//____ Vertex ___________________________________________________\n"
"\n"
"typedef struct\n"
"{\n"
"    vector_int2     coord;\n"
"    int             colorOfs;              // Offset into color buffer.\n"
"    int             extrasOfs;              // Offset into extras buffer.\n"
"    vector_float2   uv;\n"
"    vector_float2   tintmapOfs;\n"
"    vector_float2   colorstripOfs;\n"
"} Vertex;\n"
"\n"
"//____ Uniform ______________________________________________\n"
"\n"
"typedef struct             // Uniform buffer object for canvas information.\n"
"{                               // DO NOT CHANGE ORDER OF MEMBERS!!!\n"
"    vector_float2   canvasDim;\n"
"    int        canvasYOfs;\n"
"    int        canvasYMul;\n"
"\n"
"    vector_float4 flatTint;\n"
"\n"
"    vector_int2     tintRectPos;\n"
"    vector_int2     tintRectSize;\n"
"\n"
"    vector_float4   topLeftTint;\n"
"    vector_float4   topRightTint;\n"
"    vector_float4   bottomRightTint;\n"
"    vector_float4   bottomLeftTint;\n"
"\n"
"    vector_int2     texSize;\n"
"} Uniform;\n"
"\n"
"\n"
"//____ BlurUniform ______________________________________________\n"
"\n"
"typedef struct             // Uniform buffer object for fragment shader blur information.\n"
"{                               // DO NOT CHANGE ORDER OF MEMBERS!!!\n"
"    vector_float4     colorMtx[9];\n"
"    vector_float2     offset[9];\n"
"} BlurUniform;\n"
"\n"
"\n"
"//____ PlotFragInput ______________________________________________\n"
"\n"
"typedef struct \n"
"{\n"
"    float4 position [[position]];\n"
"    float pointSize [[point_size]];\n"
"    float4 color;\n"
"} PlotFragInput;\n"
"\n"
"//____ LineFromToFragInput ______________________________________________\n"
"\n"
"typedef struct \n"
"{\n"
"    float4 position [[position]];\n"
"    float4 color;\n"
"    float s;\n"
"    float w;\n"
"    float slope;\n"
"    float ifSteep;\n"
"    float ifMild;\n"
"\n"
"} LineFromToFragInput;\n"
"\n"
"//____ FillFragInput ______________________________________________\n"
"\n"
"typedef struct \n"
"{\n"
"    float4 position [[position]];\n"
"    float4 color;\n"
"} FillFragInput;\n"
"\n"
"//____ FillAAFragInput ______________________________________________\n"
"\n"
"typedef struct \n"
"{\n"
"    float4 position [[position]];\n"
"    float4 color;\n"
"    float4 rect;\n"
"} FillAAFragInput;\n"
"\n"
"\n"
"//____ BlitFragInput ______________________________________________\n"
"\n"
"typedef struct \n"
"{\n"
"    float4 position [[position]];\n"
"    float4 color;\n"
"    float2 texUV;\n"
"} BlitFragInput;\n"
"\n"
"//____ PaletteBlitInterpolateFragInput ______________________________________________\n"
"\n"
"typedef struct \n"
"{\n"
"    float4 position [[position]];\n"
"    float4 color;\n"
"    float2 texUV00;\n"
"    float2 texUV11;\n"
"    float2 uvFrac;\n"
" } PaletteBlitInterpolateFragInput;\n"
"\n"
"//____ SegmentsFragInput ______________________________________________\n"
"\n"
"typedef struct \n"
"{\n"
"    float4 position [[position]];\n"
"    float4 color;\n"
"    float2 texUV;\n"
"    int segments;\n"
"    int stripesOfs;\n"
"    float2 paletteOfs;\n"
"} SegmentsFragInput;\n"
"\n"
"\n"
"\n"
"//____ plotVertexShader() ____________________________________________\n"
"\n"
"vertex PlotFragInput\n"
"plotVertexShader(uint vertexID [[vertex_id]],\n"
"             constant Vertex *pVertices [[buffer(0)]],\n"
"             constant vector_float4  *pExtras [[buffer(1)]],\n"
"             constant Uniform * pUniform[[buffer(2)]])\n"
"{\n"
"    PlotFragInput out;\n"
"\n"
"    float2 pos = (vector_float2) pVertices[vertexID].coord.xy;\n"
"\n"
"    vector_float2 canvasSize = pUniform->canvasDim;\n"
"    \n"
"    out.position = vector_float4(0.0, 0.0, 0.0, 1.0);\n"
"    out.position.x = pos.x*2 / canvasSize.x - 1.0;\n"
"    out.position.y = (pUniform->canvasYOfs + pUniform->canvasYMul*pos.y)*2 / canvasSize.y - 1.0;\n"
"\n"
"\n"
"    int     eOfs = pVertices[vertexID].extrasOfs;\n"
"    out.color = pUniform->flatTint * pExtras[eOfs];\n"
"\n"
"    out.pointSize = 1.f;\n"
"\n"
"    return out;\n"
"}\n"
"\n"
"//____ plotFragmentShader() ____________________________________________\n"
"\n"
"fragment float4 plotFragmentShader(PlotFragInput in [[stage_in]])\n"
"{\n"
"    return in.color;\n"
"};\n"
"\n"
"//____ plotFragmentShader_A8() ____________________________________________\n"
"\n"
"fragment float4 plotFragmentShader_A8(PlotFragInput in [[stage_in]])\n"
"{\n"
"    return { in.color.a, 0.0, 0.0, 0.0 };\n"
"};\n"
"\n"
"\n"
"//____ lineFromToVertexShader() ____________________________________________\n"
"\n"
"vertex LineFromToFragInput\n"
"lineFromToVertexShader(uint vertexID [[vertex_id]],\n"
"             constant Vertex *pVertices [[buffer(0)]],\n"
"             constant vector_float4  *pColor [[buffer(1)]],\n"
"             constant vector_float4  *pExtras [[buffer(2)]],\n"
"             constant Uniform * pUniform[[buffer(3)]])\n"
"{\n"
"    LineFromToFragInput out;\n"
"\n"
"    float2 pos = (vector_float2) pVertices[vertexID].coord.xy;\n"
"\n"
"    vector_float2 canvasSize = pUniform->canvasDim;\n"
"    \n"
"    out.position = vector_float4(0.0, 0.0, 0.0, 1.0);\n"
"    out.position.x = pos.x*2 / canvasSize.x - 1.0;\n"
"    out.position.y = (pUniform->canvasYOfs + pUniform->canvasYMul*pos.y)*2 / canvasSize.y - 1.0;\n"
"\n"
"\n"
"    int     colOfs = pVertices[vertexID].colorOfs;\n"
"    out.color = pUniform->flatTint * pColor[colOfs];\n"
"\n"
"    int     eOfs = pVertices[vertexID].extrasOfs;\n"
"    float4 x = pExtras[eOfs];\n"
"    out.s = x.x;\n"
"    out.w = x.y;\n"
"    out.slope = x.z;\n"
"    out.ifSteep = x.w;\n"
"    out.ifMild = 1.0 - out.ifSteep;\n"
"\n"
"    return out;\n"
"}\n"
"\n"
"//____ lineFromToFragmentShader() ____________________________________________\n"
"\n"
"fragment float4 lineFromToFragmentShader(LineFromToFragInput in [[stage_in]])\n"
"{\n"
"   float4 outColor;\n"
"\n"
"   outColor.rgb = in.color.rgb;\n"
"   outColor.a = in.color.a * clamp(in.w - abs(in.position.x*in.ifSteep + in.position.y*in.ifMild - in.s - (in.position.x*in.ifMild + in.position.y*in.ifSteep) * in.slope), 0.0, 1.0);\n"
"\n"
"   return outColor;\n"
"};\n"
"\n"
"//____ lineFromToFragmentShader_A8() ____________________________________________\n"
"\n"
"fragment float4 lineFromToFragmentShader_A8(LineFromToFragInput in [[stage_in]])\n"
"{\n"
"   float4 outColor;\n"
"   outColor.r = in.color.a * clamp(in.w - abs(in.position.x*in.ifSteep + in.position.y*in.ifMild - in.s - (in.position.x*in.ifMild + in.position.y*in.ifSteep) * in.slope), 0.0, 1.0);\n"
"\n"
"   return outColor;\n"
"};\n"
"\n"
"\n"
"//____ fillVertexShader() ____________________________________________\n"
"\n"
"vertex FillFragInput\n"
"fillVertexShader(uint vertexID [[vertex_id]],\n"
"             constant Vertex *pVertices [[buffer(0)]],\n"
"             constant vector_float4  *pColor [[buffer(1)]],\n"
"             constant vector_float4  *pExtras [[buffer(2)]],\n"
"             constant Uniform * pUniform[[buffer(3)]])\n"
"{\n"
"    FillFragInput out;\n"
"\n"
"    float2 pos = (vector_float2) pVertices[vertexID].coord.xy;\n"
"\n"
"    vector_float2 canvasSize = pUniform->canvasDim;\n"
"    \n"
"    out.position = vector_float4(0.0, 0.0, 0.0, 1.0);\n"
"    out.position.x = pos.x*2 / 512.0 - 1.0;\n"
"    out.position.y = (pUniform->canvasYOfs + pUniform->canvasYMul*pos.y)*2 / 512.0 - 1.0;\n"
"\n"
"\n"
"    int     colOfs = pVertices[vertexID].colorOfs;\n"
"    out.color = pUniform->flatTint * pColor[colOfs];\n"
"\n"
"    return out;\n"
"}\n"
"\n"
"//____ fillGradientVertexShader() ____________________________________________\n"
"\n"
"vertex FillFragInput\n"
"fillGradientVertexShader(uint vertexID [[vertex_id]],\n"
"             constant Vertex *pVertices [[buffer(0)]],\n"
"             constant vector_float4  *pColor [[buffer(1)]],\n"
"             constant vector_float4  *pExtras [[buffer(2)]],\n"
"             constant Uniform * pUniform[[buffer(3)]])\n"
"{\n"
"    FillFragInput out;\n"
"\n"
"    float2 pos = (vector_float2) pVertices[vertexID].coord.xy;\n"
"\n"
"    vector_float2 canvasSize = pUniform->canvasDim;\n"
"    \n"
"    out.position = vector_float4(0.0, 0.0, 0.0, 1.0);\n"
"    out.position.x = pos.x*2 / canvasSize.x - 1.0;\n"
"    out.position.y = (pUniform->canvasYOfs + pUniform->canvasYMul*pos.y)*2 / canvasSize.y - 1.0;\n"
"\n"
"    float2   tintOfs = (pos - float2(pUniform->tintRectPos)) / float2(pUniform->tintRectSize);\n"
"    float4   lineStartTint = pUniform->topLeftTint + (pUniform->bottomLeftTint - pUniform->topLeftTint) * tintOfs.y;\n"
"    float4   lineEndTint = pUniform->topRightTint + (pUniform->bottomRightTint - pUniform->topRightTint) * tintOfs.y;\n"
"    float4   gradientTint = lineStartTint + (lineEndTint - lineStartTint) * tintOfs.x;\n"
"\n"
"    int     eOfs = pVertices[vertexID].extrasOfs;\n"
"    out.color = pUniform->flatTint * gradientTint * pExtras[eOfs];\n"
"\n"
"    return out;\n"
"}\n"
"\n"
"//____ fillFragmentShader() ____________________________________________\n"
"\n"
"fragment float4 fillFragmentShader(FillFragInput in [[stage_in]])\n"
"{\n"
"    return in.color;\n"
"};\n"
"\n"
"//____ fillFragmentShader_A8() ____________________________________________\n"
"\n"
"fragment float4 fillFragmentShader_A8(FillFragInput in [[stage_in]])\n"
"{\n"
"    return {in.color.a,0.0,0.0,0.0};\n"
"};\n"
"\n"
"\n"
"//____ fillAAVertexShader() ____________________________________________\n"
"\n"
"vertex FillAAFragInput\n"
"fillAAVertexShader(uint vertexID [[vertex_id]],\n"
"             constant Vertex *pVertices [[buffer(0)]],\n"
"             constant vector_float4  *pColor [[buffer(1)]],\n"
"             constant vector_float4  *pExtras [[buffer(2)]],\n"
"             constant Uniform * pUniform[[buffer(3)]])\n"
"{\n"
"    FillAAFragInput out;\n"
"\n"
"    float2 pos = (vector_float2) pVertices[vertexID].coord.xy;\n"
"\n"
"    vector_float2 canvasSize = pUniform->canvasDim;\n"
"    \n"
"    out.position = vector_float4(0.0, 0.0, 0.0, 1.0);\n"
"    out.position.x = pos.x*2 / canvasSize.x - 1.0;\n"
"    out.position.y = (pUniform->canvasYOfs + pUniform->canvasYMul*pos.y)*2 / canvasSize.y - 1.0;\n"
"\n"
"\n"
"    int     colOfs = pVertices[vertexID].colorOfs;\n"
"    out.color = pUniform->flatTint * pColor[colOfs];\n"
"\n"
"    int     eOfs = pVertices[vertexID].extrasOfs;\n"
"    out.rect = pExtras[eOfs];\n"
"//    out.rect.y = pUniform->canvasYOfs + pUniform->canvasYMul*out.rect.y;\n"
"    out.rect.zw += float2(0.5f,0.5f);\n"
"\n"
"    return out;\n"
"}\n"
"\n"
"\n"
"//____ fillGradientAAVertexShader() ____________________________________________\n"
"\n"
"vertex FillAAFragInput\n"
"fillGradientAAVertexShader(uint vertexID [[vertex_id]],\n"
"             constant Vertex *pVertices [[buffer(0)]],\n"
"             constant vector_float4  *pColor [[buffer(1)]],\n"
"             constant vector_float4  *pExtras [[buffer(2)]],\n"
"             constant Uniform * pUniform[[buffer(3)]])\n"
"{\n"
"    FillAAFragInput out;\n"
"\n"
"    float2 pos = (vector_float2) pVertices[vertexID].coord.xy;\n"
"\n"
"    vector_float2 canvasSize = pUniform->canvasDim;\n"
"    \n"
"    out.position = vector_float4(0.0, 0.0, 0.0, 1.0);\n"
"    out.position.x = pos.x*2 / canvasSize.x - 1.0;\n"
"    out.position.y = (pUniform->canvasYOfs + pUniform->canvasYMul*pos.y)*2 / canvasSize.y - 1.0;\n"
"\n"
"    float2   tintOfs = (pos - float2(pUniform->tintRectPos)) / float2(pUniform->tintRectSize);\n"
"    float4   lineStartTint = pUniform->topLeftTint + (pUniform->bottomLeftTint - pUniform->topLeftTint) * tintOfs.y;\n"
"    float4   lineEndTint = pUniform->topRightTint + (pUniform->bottomRightTint - pUniform->topRightTint) * tintOfs.y;\n"
"    float4   gradientTint = lineStartTint + (lineEndTint - lineStartTint) * tintOfs.x;\n"
"\n"
"    int     eOfs = pVertices[vertexID].extrasOfs;\n"
"    out.color = pUniform->flatTint * gradientTint * pExtras[eOfs];\n"
"\n"
"    out.rect = pExtras[eOfs+1];\n"
"//    out.rect.y = pUniform->canvasYOfs + pUniform->canvasYMul*out.rect.y;\n"
"    out.rect.zw += float2(0.5f,0.5f);\n"
"\n"
"    return out;\n"
"}\n"
"\n"
"//____ fillAAFragmentShader() ____________________________________________\n"
"\n"
"fragment float4 fillAAFragmentShader(FillAAFragInput in [[stage_in]])\n"
"{\n"
"    float4 color = in.color;\n"
"    float2 middleofs = abs(in.position.xy - in.rect.xy);\n"
"    float2 alphas = clamp(in.rect.zw  - middleofs, 0.f, 1.f);\n"
"    color.a = in.color.a * alphas.x * alphas.y;\n"
"\n"
"    return color;\n"
"};\n"
"\n"
"//____ fillAAFragmentShader_A8() ____________________________________________\n"
"\n"
"fragment float4 fillAAFragmentShader_A8(FillAAFragInput in [[stage_in]])\n"
"{\n"
"    float2 middleofs = abs(in.position.xy - in.rect.xy);\n"
"    float2 alphas = clamp(in.rect.zw  - middleofs, 0.f, 1.f);\n"
"    \n"
"    return { in.color.a * alphas.x * alphas.y, 0.0, 0.0, 0.0 };\n"
"};\n"
"\n"
"//____ blitVertexShader() _______________________________________________\n"
"\n"
"vertex BlitFragInput\n"
"blitVertexShader(uint vertexID [[vertex_id]],\n"
"             constant Vertex *pVertices [[buffer(0)]],\n"
"             constant vector_float4  *pColor [[buffer(1)]],\n"
"             constant vector_float4  *pExtras [[buffer(2)]],\n"
"             constant Uniform * pUniform[[buffer(3)]])\n"
"{\n"
"    BlitFragInput out;\n"
"\n"
"    float2 pos = (vector_float2) pVertices[vertexID].coord.xy;\n"
"\n"
"    vector_float2 canvasSize = pUniform->canvasDim;\n"
"    \n"
"    out.position = vector_float4(0.0, 0.0, 0.0, 1.0);\n"
"    out.position.x = pos.x*2 / canvasSize.x - 1.0;\n"
"    out.position.y = (pUniform->canvasYOfs + pUniform->canvasYMul*pos.y)*2 / canvasSize.y - 1.0;\n"
"\n"
"\n"
"    int     eOfs = pVertices[vertexID].extrasOfs;\n"
"\n"
"    vector_float4 srcDst = pExtras[eOfs];\n"
"    vector_float4 transform = pExtras[eOfs+1];\n"
"    vector_float2 src = srcDst.xy;\n"
"    vector_float2 dst = srcDst.zw;\n"
"\n"
"    out.texUV.x = (src.x + 0.0001f + (pos.x - dst.x) * transform.x + (pos.y - dst.y) * transform.z) / pUniform->texSize.x;      //TODO: Replace this ugly +0.02f fix with whatever is correct.\n"
"    out.texUV.y = (src.y + 0.0001f + (pos.x - dst.x) * transform.y + (pos.y - dst.y) * transform.w) / pUniform->texSize.y;      //TODO: Replace this ugly +0.02f fix with whatever is correct.\n"
"\n"
"    out.color = pUniform->flatTint;\n"
"\n"
"    return out;\n"
"}\n"
"\n"
"//____ blitGradientVertexShader() _______________________________________________\n"
"\n"
"\n"
"vertex BlitFragInput\n"
"blitGradientVertexShader(uint vertexID [[vertex_id]],\n"
"             constant Vertex *pVertices [[buffer(0)]],\n"
"             constant vector_float4  *pExtras [[buffer(1)]],\n"
"             constant Uniform * pUniform[[buffer(2)]])\n"
"{\n"
"    BlitFragInput out;\n"
"\n"
"    float2 pos = (vector_float2) pVertices[vertexID].coord.xy;\n"
"\n"
"    vector_float2 canvasSize = pUniform->canvasDim;\n"
"    \n"
"    out.position = vector_float4(0.0, 0.0, 0.0, 1.0);\n"
"    out.position.x = pos.x*2 / canvasSize.x - 1.0;\n"
"    out.position.y = (pUniform->canvasYOfs + pUniform->canvasYMul*pos.y)*2 / canvasSize.y - 1.0;\n"
"\n"
"\n"
"    int     eOfs = pVertices[vertexID].extrasOfs;\n"
"\n"
"    vector_float4 srcDst = pExtras[eOfs];\n"
"    vector_float4 transform = pExtras[eOfs+1];\n"
"    vector_float2 src = srcDst.xy;\n"
"    vector_float2 dst = srcDst.zw;\n"
"\n"
"    out.texUV.x = (src.x + 0.0001f + (pos.x - dst.x) * transform.x + (pos.y - dst.y) * transform.z) / pUniform->texSize.x;      //TODO: Replace this ugly +0.02f fix with whatever is correct.\n"
"    out.texUV.y = (src.y + 0.0001f + (pos.x - dst.x) * transform.y + (pos.y - dst.y) * transform.w) / pUniform->texSize.y;      //TODO: Replace this ugly +0.02f fix with whatever is correct.\n"
"\n"
"    float2   tintOfs = (pos - float2(pUniform->tintRectPos)) / float2(pUniform->tintRectSize);\n"
"    float4   lineStartTint = pUniform->topLeftTint + (pUniform->bottomLeftTint - pUniform->topLeftTint) * tintOfs.y;\n"
"    float4   lineEndTint = pUniform->topRightTint + (pUniform->bottomRightTint - pUniform->topRightTint) * tintOfs.y;\n"
"    float4   gradientTint = lineStartTint + (lineEndTint - lineStartTint) * tintOfs.x;\n"
"\n"
"    out.color = pUniform->flatTint * gradientTint;\n"
"\n"
"    return out;\n"
"}\n"
"\n"
"//____ blitFragmentShader() ____________________________________________\n"
"\n"
"fragment float4 blitFragmentShader(BlitFragInput in [[stage_in]],\n"
"                                    texture2d<half> colorTexture [[ texture(0) ]],\n"
"                                    sampler textureSampler [[ sampler(0) ]])\n"
"{\n"
"    const half4 colorSample = colorTexture.sample(textureSampler, in.texUV);\n"
"\n"
"    return float4(colorSample) * in.color;\n"
"};\n"
"\n"
"//____ blitFragmentShader_A8() ____________________________________________\n"
"\n"
"fragment float4 blitFragmentShader_A8(BlitFragInput in [[stage_in]],\n"
"                                    texture2d<half> colorTexture [[ texture(0) ]],\n"
"                                    sampler textureSampler [[ sampler(0) ]])\n"
"{\n"
"    const float colorSample = float(colorTexture.sample(textureSampler, in.texUV).a);\n"
"\n"
"    return { colorSample * in.color.a, 0.0, 0.0, 0.0 };\n"
"};\n"
"\n"
"//____ rgbxBlitFragmentShader() ____________________________________________\n"
"\n"
"fragment float4 rgbxBlitFragmentShader(BlitFragInput in [[stage_in]],\n"
"                                    texture2d<half> colorTexture [[ texture(0) ]],\n"
"                                    sampler textureSampler [[ sampler(0) ]])\n"
"{\n"
"    half4 colorSample = colorTexture.sample(textureSampler, in.texUV);\n"
"    colorSample.a = (half) 1.0;\n"
"\n"
"    return float4(colorSample) * in.color;\n"
"};\n"
"\n"
"//____ rgbxBlitFragmentShader_A8() ____________________________________________\n"
"\n"
"fragment float4 rgbxBlitFragmentShader_A8(BlitFragInput in [[stage_in]],\n"
"                                    texture2d<half> colorTexture [[ texture(0) ]],\n"
"                                    sampler textureSampler [[ sampler(0) ]])\n"
"{\n"
"    return { in.color.a, 0.0, 0.0, 0.0 };\n"
"};\n"
"\n"
"\n"
"//____ alphaBlitFragmentShader() ____________________________________________\n"
"\n"
"fragment float4 alphaBlitFragmentShader(BlitFragInput in [[stage_in]],\n"
"                                    texture2d<half> colorTexture [[ texture(0) ]],\n"
"                                    sampler textureSampler [[ sampler(0) ]])\n"
"{\n"
"    float4 color = in.color;\n"
"    color.a *= colorTexture.sample(textureSampler, in.texUV).r;\n"
"\n"
"    return color;\n"
"};\n"
"\n"
"//____ alphaBlitFragmentShader_A8() ____________________________________________\n"
"\n"
"fragment float4 alphaBlitFragmentShader_A8(BlitFragInput in [[stage_in]],\n"
"                                    texture2d<half> colorTexture [[ texture(0) ]],\n"
"                                    sampler textureSampler [[ sampler(0) ]])\n"
"{\n"
"    const float colorSample = float(colorTexture.sample(textureSampler, in.texUV).r);\n"
"\n"
"    return { colorSample * in.color.a, 0.0, 0.0, 0.0 };\n"
"};\n"
"\n"
"\n"
"\n"
"//____ paletteBlitNearestFragmentShader() ____________________________________________\n"
"\n"
"fragment float4 paletteBlitNearestFragmentShader(BlitFragInput in [[stage_in]],\n"
"                                    texture2d<float> colorTexture [[ texture(0) ]],\n"
"                                    texture2d<half> paletteTexture [[ texture(1) ]],\n"
"                                    sampler textureSampler [[ sampler(0) ]])\n"
"{\n"
"    constexpr sampler paletteSampler (mag_filter::nearest,\n"
"                                      min_filter::nearest);\n"
"\n"
"    const float colorIndex = colorTexture.sample(textureSampler, in.texUV).r;\n"
"    const half4 colorSample = paletteTexture.sample(paletteSampler, {colorIndex,0.5f} );\n"
"\n"
"//    return in.color;\n"
"    return float4(colorSample) * in.color;\n"
"};\n"
"\n"
"//____ paletteBlitNearestFragmentShader_A8() ____________________________________________\n"
"\n"
"fragment float4 paletteBlitNearestFragmentShader_A8(BlitFragInput in [[stage_in]],\n"
"                                    texture2d<float> colorTexture [[ texture(0) ]],\n"
"                                    texture2d<half> paletteTexture [[ texture(1) ]],\n"
"                                    sampler textureSampler [[ sampler(0) ]])\n"
"{\n"
"    constexpr sampler paletteSampler (mag_filter::nearest,\n"
"                                      min_filter::nearest);\n"
"\n"
"    const float colorIndex = colorTexture.sample(textureSampler, in.texUV).r;\n"
"    const float colorSample = paletteTexture.sample(paletteSampler, {colorIndex,0.5f} ).a;\n"
"\n"
"    return { colorSample * in.color.a, 0.0, 0.0, 0.0 };\n"
"};\n"
"\n"
"\n"
"//____ paletteBlitInterpolateVertexShader() _______________________________________________\n"
"\n"
"vertex PaletteBlitInterpolateFragInput\n"
"paletteBlitInterpolateVertexShader(uint vertexID [[vertex_id]],\n"
"             constant Vertex *pVertices [[buffer(0)]],\n"
"             constant vector_float4  *pExtras [[buffer(1)]],\n"
"             constant Uniform * pUniform[[buffer(2)]])\n"
"{\n"
"    PaletteBlitInterpolateFragInput out;\n"
"\n"
"    float2 pos = (vector_float2) pVertices[vertexID].coord.xy;\n"
"\n"
"    vector_float2 canvasSize = pUniform->canvasDim;\n"
"    \n"
"    out.position = vector_float4(0.0, 0.0, 0.0, 1.0);\n"
"    out.position.x = pos.x*2 / canvasSize.x - 1.0;\n"
"    out.position.y = (pUniform->canvasYOfs + pUniform->canvasYMul*pos.y)*2 / canvasSize.y - 1.0;\n"
"\n"
"\n"
"    int     eOfs = pVertices[vertexID].extrasOfs;\n"
"\n"
"    vector_float4 srcDst = pExtras[eOfs];\n"
"    vector_float4 transform = pExtras[eOfs+1];\n"
"    vector_float2 src = srcDst.xy;\n"
"    vector_float2 dst = srcDst.zw;\n"
"\n"
"    float2 texUV = src + (pos-dst) * transform.xw + (pos.yx - dst.yx) * transform.zy;\n"
"    texUV -= 0.5f;\n"
"\n"
"    out.uvFrac = texUV;\n"
"    out.texUV00 = texUV/ (float2) pUniform->texSize;\n"
"    out.texUV11 = (texUV+1)/ (float2) pUniform->texSize;\n"
"\n"
"    out.color = pUniform->flatTint;\n"
"\n"
"    return out;\n"
"}\n"
"\n"
"//____ paletteBlitInterpolateGradientVertexShader() _______________________________________________\n"
"\n"
"vertex PaletteBlitInterpolateFragInput\n"
"paletteBlitInterpolateGradientVertexShader(uint vertexID [[vertex_id]],\n"
"             constant Vertex *pVertices [[buffer(0)]],\n"
"             constant vector_float4  *pExtras [[buffer(1)]],\n"
"             constant Uniform * pUniform[[buffer(2)]])\n"
"{\n"
"    PaletteBlitInterpolateFragInput out;\n"
"\n"
"    float2 pos = (vector_float2) pVertices[vertexID].coord.xy;\n"
"\n"
"    vector_float2 canvasSize = pUniform->canvasDim;\n"
"    \n"
"    out.position = vector_float4(0.0, 0.0, 0.0, 1.0);\n"
"    out.position.x = pos.x*2 / canvasSize.x - 1.0;\n"
"    out.position.y = (pUniform->canvasYOfs + pUniform->canvasYMul*pos.y)*2 / canvasSize.y - 1.0;\n"
"\n"
"\n"
"    int     eOfs = pVertices[vertexID].extrasOfs;\n"
"\n"
"    vector_float4 srcDst = pExtras[eOfs];\n"
"    vector_float4 transform = pExtras[eOfs+1];\n"
"    vector_float2 src = srcDst.xy;\n"
"    vector_float2 dst = srcDst.zw;\n"
"\n"
"    float2 texUV = src + (pos-dst) * transform.xw + (pos.yx - dst.yx) * transform.zy;\n"
"    texUV -= 0.5f;\n"
"\n"
"    out.uvFrac = texUV;\n"
"    out.texUV00 = texUV/ (float2) pUniform->texSize;\n"
"    out.texUV11 = (texUV+1)/ (float2) pUniform->texSize;\n"
"\n"
"    float2   tintOfs = (pos - float2(pUniform->tintRectPos)) / float2(pUniform->tintRectSize);\n"
"    float4   lineStartTint = pUniform->topLeftTint + (pUniform->bottomLeftTint - pUniform->topLeftTint) * tintOfs.y;\n"
"    float4   lineEndTint = pUniform->topRightTint + (pUniform->bottomRightTint - pUniform->topRightTint) * tintOfs.y;\n"
"    float4   gradientTint = lineStartTint + (lineEndTint - lineStartTint) * tintOfs.x;\n"
"\n"
"    out.color = pUniform->flatTint * gradientTint;\n"
"\n"
"    return out;\n"
"}\n"
"\n"
"//____ paletteBlitInterpolateFragmentShader() ____________________________________________\n"
"\n"
"fragment float4 paletteBlitInterpolateFragmentShader(PaletteBlitInterpolateFragInput in [[stage_in]],\n"
"                                    texture2d<float> colorTexture [[ texture(0) ]],\n"
"                                    texture2d<half> paletteTexture [[ texture(1) ]],\n"
"                                    sampler textureSampler [[ sampler(0) ]])\n"
"{\n"
"    constexpr sampler paletteSampler (mag_filter::nearest,\n"
"                                      min_filter::nearest);\n"
"\n"
"   float index00 = colorTexture.sample(textureSampler, in.texUV00).r;\n"
"   float index01 = colorTexture.sample(textureSampler, float2(in.texUV11.x,in.texUV00.y) ).r;\n"
"   float index10 = colorTexture.sample(textureSampler, float2(in.texUV00.x,in.texUV11.y) ).r;\n"
"   float index11 = colorTexture.sample(textureSampler, in.texUV11).r;\n"
"   half4 color00 = paletteTexture.sample(paletteSampler, float2(index00,0.5f));\n"
"   half4 color01 = paletteTexture.sample(paletteSampler, float2(index01,0.5f));\n"
"   half4 color10 = paletteTexture.sample(paletteSampler, float2(index10,0.5f));\n"
"   half4 color11 = paletteTexture.sample(paletteSampler, float2(index11,0.5f));\n"
"\n"
"   half4 out0 = color00 * (1-fract(in.uvFrac.x)) + color01 * fract(in.uvFrac.x);\n"
"   half4 out1 = color10 * (1-fract(in.uvFrac.x)) + color11 * fract(in.uvFrac.x);\n"
"   half4 colorSample = (out0 * (1-fract(in.uvFrac.y)) + out1 * fract(in.uvFrac.y));\n"
"\n"
"    return float4(colorSample) * in.color;\n"
"};\n"
"\n"
"//____ paletteBlitInterpolateFragmentShader_A8() ____________________________________________\n"
"\n"
"fragment float4 paletteBlitInterpolateFragmentShader_A8(PaletteBlitInterpolateFragInput in [[stage_in]],\n"
"                                    texture2d<float> colorTexture [[ texture(0) ]],\n"
"                                    texture2d<half> paletteTexture [[ texture(1) ]],\n"
"                                    sampler textureSampler [[ sampler(0) ]])\n"
"{\n"
"    constexpr sampler paletteSampler (mag_filter::nearest,\n"
"                                      min_filter::nearest);\n"
"\n"
"   float index00 = colorTexture.sample(textureSampler, in.texUV00).r;\n"
"   float index01 = colorTexture.sample(textureSampler, float2(in.texUV11.x,in.texUV00.y) ).r;\n"
"   float index10 = colorTexture.sample(textureSampler, float2(in.texUV00.x,in.texUV11.y) ).r;\n"
"   float index11 = colorTexture.sample(textureSampler, in.texUV11).r;\n"
"   float color00 = paletteTexture.sample(paletteSampler, float2(index00,0.5f)).a;\n"
"   float color01 = paletteTexture.sample(paletteSampler, float2(index01,0.5f)).a;\n"
"   float color10 = paletteTexture.sample(paletteSampler, float2(index10,0.5f)).a;\n"
"   float color11 = paletteTexture.sample(paletteSampler, float2(index11,0.5f)).a;\n"
"\n"
"   float out0 = color00 * (1-fract(in.uvFrac.x)) + color01 * fract(in.uvFrac.x);\n"
"   float out1 = color10 * (1-fract(in.uvFrac.x)) + color11 * fract(in.uvFrac.x);\n"
"   float colorSample = (out0 * (1-fract(in.uvFrac.y)) + out1 * fract(in.uvFrac.y));\n"
"\n"
"   return { colorSample * in.color.a, 0.0, 0.0, 0.0 };\n"
"};\n"
"\n"
"//____ blurFragmentShader() ____________________________________________\n"
"\n"
"fragment float4 blurFragmentShader(BlitFragInput in [[stage_in]],\n"
"                                    texture2d<float> colorTexture [[ texture(0) ]],\n"
"                                    sampler textureSampler [[ sampler(0) ]],\n"
"                                    constant BlurUniform  *pBlurInfo [[buffer(1)]])\n"
"{\n"
"\n"
"   float4 color = colorTexture.sample(textureSampler, in.texUV + pBlurInfo->offset[0] ) * pBlurInfo->colorMtx[0];\n"
"   color += colorTexture.sample(textureSampler, in.texUV + pBlurInfo->offset[1] ) * pBlurInfo->colorMtx[1];\n"
"   color += colorTexture.sample(textureSampler, in.texUV + pBlurInfo->offset[2] ) * pBlurInfo->colorMtx[2];\n"
"\n"
"   color += colorTexture.sample(textureSampler, in.texUV + pBlurInfo->offset[3] ) * pBlurInfo->colorMtx[3];\n"
"   color += colorTexture.sample(textureSampler, in.texUV + pBlurInfo->offset[4] ) * pBlurInfo->colorMtx[4];\n"
"   color += colorTexture.sample(textureSampler, in.texUV + pBlurInfo->offset[5] ) * pBlurInfo->colorMtx[5];\n"
"\n"
"   color += colorTexture.sample(textureSampler, in.texUV + pBlurInfo->offset[6] ) * pBlurInfo->colorMtx[6];\n"
"   color += colorTexture.sample(textureSampler, in.texUV + pBlurInfo->offset[7] ) * pBlurInfo->colorMtx[7];\n"
"   color += colorTexture.sample(textureSampler, in.texUV + pBlurInfo->offset[8] ) * pBlurInfo->colorMtx[8];\n"
"\n"
"   color.a = 1.f;\n"
"    return color * in.color;\n"
"};\n"
"\n"
"//____ segmentsVertexShader() _______________________________________________\n"
"\n"
"vertex SegmentsFragInput\n"
"segmentsVertexShader(uint vertexID [[vertex_id]],\n"
"             constant Vertex *pVertices [[buffer(0)]],\n"
"             constant vector_float4  *pExtras [[buffer(1)]],\n"
"             constant Uniform * pUniform[[buffer(2)]])\n"
"{\n"
"    SegmentsFragInput out;\n"
"\n"
"    float2 pos = (vector_float2) pVertices[vertexID].coord.xy;\n"
"\n"
"    vector_float2 canvasSize = pUniform->canvasDim;\n"
"    \n"
"    out.position = vector_float4(0.0, 0.0, 0.0, 1.0);\n"
"    out.position.x = pos.x*2 / canvasSize.x - 1.0;\n"
"    out.position.y = (pUniform->canvasYOfs + pUniform->canvasYMul*pos.y)*2 / canvasSize.y - 1.0;\n"
"\n"
"\n"
"    int     eOfs = pVertices[vertexID].extrasOfs;\n"
"\n"
"    vector_float4 extras = pExtras[eOfs];\n"
"    vector_float4 extras2 = pExtras[eOfs+1];\n"
"\n"
"    out.segments = int(extras.x);\n"
"    out.stripesOfs = int(extras.y);\n"
" \n"
"    float2 uv = pVertices[vertexID].uv;\n"
"    out.texUV = uv;\n"
"\n"
"    float xTintOfs = uv.x/extras.z*1/extras2.z;\n"
"    float yTintOfs = uv.y/extras.w*1/extras2.w;\n"
"\n"
"    out.paletteOfs = { extras2.x+xTintOfs, extras2.y+yTintOfs };\n"
"    out.color = pUniform->flatTint;\n"
"\n"
"    return out;\n"
"}\n"
"\n"
"//____ segmentsGradientVertexShader() _______________________________________________\n"
"\n"
"vertex SegmentsFragInput\n"
"segmentsGradientVertexShader(uint vertexID [[vertex_id]],\n"
"             constant Vertex *pVertices [[buffer(0)]],\n"
"             constant vector_float4  *pExtras [[buffer(1)]],\n"
"             constant Uniform * pUniform[[buffer(2)]])\n"
"{\n"
"    SegmentsFragInput out;\n"
"\n"
"    float2 pos = (vector_float2) pVertices[vertexID].coord.xy;\n"
"\n"
"    vector_float2 canvasSize = pUniform->canvasDim;\n"
"    \n"
"    out.position = vector_float4(0.0, 0.0, 0.0, 1.0);\n"
"    out.position.x = pos.x*2 / canvasSize.x - 1.0;\n"
"    out.position.y = (pUniform->canvasYOfs + pUniform->canvasYMul*pos.y)*2 / canvasSize.y - 1.0;\n"
"\n"
"\n"
"    int     eOfs = pVertices[vertexID].extrasOfs;\n"
"\n"
"    vector_float4 extras = pExtras[eOfs];\n"
"    vector_float4 extras2 = pExtras[eOfs+1];\n"
"\n"
"    out.segments = int(extras.x);\n"
"    out.stripesOfs = int(extras.y);\n"
" \n"
"    float2 uv = pVertices[vertexID].uv;\n"
"    out.texUV = uv;\n"
"\n"
"    float xTintOfs = uv.x/extras.z*1/extras2.z;\n"
"    float yTintOfs = uv.y/extras.w*1/extras2.w;\n"
"\n"
"    out.paletteOfs = { extras2.x+xTintOfs, extras2.y+yTintOfs };\n"
" \n"
"    float2   tintOfs = (pos - float2(pUniform->tintRectPos)) / float2(pUniform->tintRectSize);\n"
"    float4   lineStartTint = pUniform->topLeftTint + (pUniform->bottomLeftTint - pUniform->topLeftTint) * tintOfs.y;\n"
"    float4   lineEndTint = pUniform->topRightTint + (pUniform->bottomRightTint - pUniform->topRightTint) * tintOfs.y;\n"
"    float4   gradientTint = lineStartTint + (lineEndTint - lineStartTint) * tintOfs.x;\n"
"\n"
"    out.color = pUniform->flatTint * gradientTint;\n"
"\n"
"    return out;\n"
"}\n"
"\n"
"\n"
"//____ segmentsFragmentShader() ____________________________________________\n"
"\n"
"template <int EDGES>\n"
"inline float4 segFragShaderCore(SegmentsFragInput in,\n"
"                                    constant float4  *pEdgeStripes,\n"
"                                    texture2d<half> paletteTexture)\n"
"{\n"
"\n"
"    constexpr sampler textureSampler (mag_filter::linear,\n"
"                                      min_filter::linear);\n"
"\n"
"    float totalAlpha = 0.f;\n"
"    float3    rgbAcc = float3(0,0,0);\n"
"\n"
"    float factor = 1.f;\n"
"    float2 palOfs = in.paletteOfs;\n"
"    for( int i = 0 ; i < EDGES ; i++ )\n"
"    {\n"
"        float4 col = (float4) paletteTexture.sample(textureSampler, palOfs);\n"
"        palOfs.x += 1/(float) $MAXSEG;\n"
"\n"
"        float4 edge = pEdgeStripes[in.stripesOfs + int(in.texUV.x)*(in.segments-1)+i];\n"
"\n"
"        float x = (in.texUV.y - edge.r) * edge.g;\n"
"        float adder = edge.g / 2.f;\n"
"        if (x < 0.f)\n"
"            adder = edge.b;\n"
"        else if (x + edge.g > 1.f)\n"
"            adder = edge.a;\n"
"        float factor2 = clamp(x + adder, 0.f, 1.f);\n"
"\n"
"        float useFactor = (factor - factor2)*col.a;\n"
"        totalAlpha += useFactor;\n"
"        rgbAcc += col.rgb * useFactor;\n"
"\n"
"        factor = factor2;\n"
"    }\n"
"\n"
"    float4 col = (float4) paletteTexture.sample(textureSampler, palOfs);\n"
"    float useFactor = factor*col.a;\n"
"    totalAlpha += useFactor;\n"
"    rgbAcc += col.rgb * useFactor;\n"
"\n"
"    float4 out;\n"
"    out.a = totalAlpha * in.color.a;\n"
"    out.rgb = (rgbAcc/totalAlpha) * in.color.rgb;\n"
"    return out;\n"
"};\n"
"\n"
"\n"
"fragment float4 segmentsFragmentShader1(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore<1>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader2(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore<2>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader3(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore<3>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader4(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore<4>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader5(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore<5>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader6(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore<6>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader7(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore<7>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader8(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore<8>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader9(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore<9>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader10(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore<10>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader11(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore<11>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader12(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore<12>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader13(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore<13>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader14(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore<14>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader15(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore<15>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"//____ segmentsFragmentShader_A8() ____________________________________________\n"
"\n"
"template <int EDGES>\n"
"inline float4 segFragShaderCore_A8(SegmentsFragInput in,\n"
"                                    constant float4  *pEdgeStripes,\n"
"                                    texture2d<half> paletteTexture)\n"
"{\n"
"\n"
"    constexpr sampler textureSampler (mag_filter::linear,\n"
"                                      min_filter::linear);\n"
"\n"
"    float totalAlpha = 0.f;\n"
"\n"
"    float factor = 1.f;\n"
"    float2 palOfs = in.paletteOfs;\n"
"    for( int i = 0 ; i < EDGES ; i++ )\n"
"    {\n"
"        float alpha = (float) paletteTexture.sample(textureSampler, palOfs).a;\n"
"        palOfs.x += 1/$MAXSEG.f;\n"
"\n"
"        float4 edge = pEdgeStripes[in.stripesOfs + int(in.texUV.x)*(in.segments-1)+i];\n"
"\n"
"        float x = (in.texUV.y - edge.r) * edge.g;\n"
"        float adder = edge.g / 2.f;\n"
"        if (x < 0.f)\n"
"            adder = edge.b;\n"
"        else if (x + edge.g > 1.f)\n"
"            adder = edge.a;\n"
"        float factor2 = clamp(x + adder, 0.f, 1.f);\n"
"\n"
"        totalAlpha += (factor - factor2)*alpha;\n"
"\n"
"        factor = factor2;\n"
"    }\n"
"\n"
"    float alpha = (float) paletteTexture.sample(textureSampler, palOfs).a;\n"
"    totalAlpha += factor*alpha;\n"
"\n"
"    return { totalAlpha * in.color.a, 0.f, 0.f, 0.f };\n"
"};\n"
"\n"
"\n"
"fragment float4 segmentsFragmentShader1_A8(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore_A8<1>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader2_A8(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore_A8<2>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader3_A8(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore_A8<3>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader4_A8(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore_A8<4>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader5_A8(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore_A8<5>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader6_A8(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore_A8<6>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader7_A8(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore_A8<7>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader8_A8(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore_A8<8>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader9_A8(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore_A8<9>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader10_A8(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore_A8<10>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader11_A8(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore_A8<11>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader12_A8(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore_A8<12>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader13_A8(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore_A8<13>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader14_A8(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore_A8<14>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
"\n"
"fragment float4 segmentsFragmentShader15_A8(SegmentsFragInput in [[stage_in]],\n"
"                                    constant float4  *pEdgeStripes [[buffer(0)]],\n"
"                                    texture2d<half> paletteTexture [[ texture(2) ]])\n"
"{\n"
"    return segFragShaderCore_A8<15>(in,pEdgeStripes,paletteTexture);\n"
"};\n"
;}
